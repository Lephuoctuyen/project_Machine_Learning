# -*- coding: utf-8 -*-
"""project_1.2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11EcgEJqIC8G08KNJ8KcpxixIak2czknV

# Hybrid Recommendation Systems

có nhiều loại Hybrid Recommendation Systems và tôi sẽ chọn vài loại tiêu biểu
"""

import pandas as pd
import numpy as np

"""# Weigh Hybrid Recommendation Systems

![1_N9TO6n2tlo1sN8GhsB-tqw.webp](data:image/webp;base64,UklGRtYZAABXRUJQVlA4WAoAAAAIAAAAzwIA2AAAVlA4IPYYAABQfwCdASrQAtkAPm02lUikIy4hIdJq0cANiWlu5KgXFEUQ7OvD9m/832z/2r8jPPn8T+WfqP5BaA/8i+t33H+yft3/hPcX/AeCPwx/lfUC/Gv5D/ZPuK40bNPMI9LPmP92/s34++g/+0f1L1F+o3+T/Mz6AP5B/Mf8X+VP9l////f+zP9v4Rf1r/G/8v3Af5F/TP9B/dP85/6v8t9MH8l/x/8n+WHtT/Nv7//zf8t/of2a+wT+Q/0T/b/3H/G/td88Hr2/cP/7e6F+y//3ITK8S5SGZ8O5eIx9EIBTDuXiMfRCAUw7l4jH0QgBio0hCdLUUUUTl/qJIncvEY+iEAph3LxGPohAKYdy4STqMmDeM6jo6GOg+cy++Ayrgh4iZ/lo9kp8O5eIx9EIBTDuXiMfRB8Gw5jvUQPeiz+HiF/AZcLzFVakAUedSeo6kZg2wg5G1jfKGgShhQU5hIDOvDliABTnvxWQE0DfIr/8X7LMz4dy8Rj6IQCmHYJIrCT3JAbE000zs0XvS4b67I8bT981tBhMx4GmZf3dErPF63eWXGAwqEHC0Nqib4lK23IijsCjEauH87ojybXIMu9JZ+oGgckhY4Gh+/xsiSSMmIIIIIIGixGYVocZBzJg4hr3/l3ZCg2rLLW1le9m0mkn2cW4kmfbhIpETcEAl8gix+MuUhmcGj+m6ZqlHBCFm+Nn3EQI1MWE2BWJUGKNzHNcWzy8PVjUnQMNaL3ILHHHG81rHb6QUUDPY0DDT9/rHZaTr9KGHAqLpeLs5QANRf3XfW/k4+b6abPmeTw5cwgXK2YuX6Squ1HT+VfssG6Hq5u8dBKcVMLj2RN3pfw86rqYw5zLLjofO8OYt4YnJKRH4xCxy6JnFF2tfmsW84eubJRPW3XXXXXJRmJ3WBglnYtGsub9PuDgbm0S5MgbP8QOauJM8jCyPAcjxckURMMDRK03bW01B5UlJd/uYqTSBDdIa/mTYMF/MXqqkmcz7n8CtcsAVXPUte8K9x+E904jtFnmG8SyAYNLrrrrrrlSb47g1VjeNcNBkGAg5WaZvaeZiTgkP5xca+cjsZTgsRteRr2W1EU6BDTtzjUdfZwQMhcAN0pZ7lJbvi3n/AJV8GqXSbvtCA4qiaTGhzgUJsEkGQpxgLFoAXCyFOP4GX6/da2222222wmcuP7ilfog+3LKFwKuBZXSIcZt2GznJvAoDClz7sRxvUOMqyNc7E6tTK4ZjZDCoqzq8S5SGZ8O5eIx+QEAph3LxGDksFEUDOk0002aFF/BCWSuTuXiMfRCAUw7l4jH0QgFMO1R5K+8gQ+cQIqb4VEIBTDuXiMfRCAUw7l4jH0QgFMO5eIx9EIBTDuXiMfRB7wAAP7/MQAATgPl/8v4L8ksxcZPfQifAxwREwNfid4aykYlyBI0HgEEZeo0o7w5hXchU5AFytLUffEEl3jHC2XgysHYAOQCN82A+UE6Fv6c/tD/Je+Gh+WJRct+xxmAgrxtCLfDaD9t0Khh9kpB7Q/950u7rd9pCdaQRcs3S7xQPcYqALKzb4AcGAk4+uH64gM4RHbtQrY1szfGYUo3OKG5LJBEmzVuE8Mb3qE/FKp1e1O1Ohhe0hvZRj+1kjMjqEgyrDgwAIm6ATfn+IihL8PioeIQOLj9m0ceZtBI2m66P4Y24TMucHaUqkkLz+T0b4LNpBte0PfDtkn96g8C/Kr12baW8PcvVlJC95ufL9jKCgzGyAmp3F1b5r00el/j73VZWtNkIKwOj/x2/CVw8sUxhc4XRaScystGmf1l78Gj05UP8+Cwc+uH6YEEQJVRAAq+ucsKWyrfLgPa3BW/k1Ni5m+Veck/+NaAIK2lReoiWja8S3yY1QDbuM9Uy+9Jw4DfzrOpMB6Dk9u7+99hpIzTNENonlmiS2RfLLTEvyo7yclwjBgkkzeLPPyF52kYfmjyHOSanUlhJj9BoswsYmk7J/NqkFQiEy9fCHLQHcElfp8GOaCLzooZjQjDU/1T0HCThgWh7wmMLgaFOi+YXUEG2wGWd2NM4DtViZwLly6tI8IEznI6lbaWUsBzEOTiYwnAJXqj3uTpHcsugr7bzcFwvBLUCaWf64W7AAIh46mJ3Fhm5k3U4flTwZi/sryhLh0fnlxnFWpZvv0uMap3l+jCFR4M+BSwqpNyuBIK/WF2tlQCpB3YBpoVeAH2OifXcfkAiYRoj08j0p4fvhtv9ZHiWQCPS2tjwjla89Gn2FmnxFNS/a680UO51a4cQ0HL29yMoghtYHn8bjDLFA/ESeTvdh9smPjPDfGEKUovKNLSmmS4vG8iFmdYiwm45QljQDEtd3HkVDyZhzE0t3dX1H+A9RFuaz5iqJTI6xKIQqNMPdBhb40io4p+AIXCcsbKuS4k48qVlQuVL71piavY7q7/Et0R+v/bcKKRSAfe/pskDSKL4XiYy4t8sfuO324igHqTzNevkdqrZq+SImbkJIfe0dDiBJUuzZqRXTX4dOKxBLWwkl2sPRbFvkVyfrrVPbM4U9V3nakREq7dkEGwgehVmxCwOWg8Vgj6j5epJCV/ghdtX6DZ13BGBh0Q7N9upFXhHeektYa8ziO4iF6AsWOe//gwBTaY/CbEuDZlOUR03gUcrbRJrNv7rfDkkTWgj2911Kaf7Il9u4XV3jat/FgcBywtLkyliJcrLULoDi3+MFvmVndJnAcn+joWq0lkXTy95Oc1tLARXq2DdU9FJOGXwYPsDIZJtFsb+ceLI4WzCAbYmJXX4uSt5CzH9yB3Itb55SsVw4b759YPw404Nwz9sEZfeoQ/ey+IQicqZmWZ9FdZWqzdOaxdXPexru9LnaU5zFThkJ6tsdLGacpJ//O2/8NgFYiOTHA/B+2LLVz4E2b0WQk1xEEmaA1crjh22yNBJniuvJaM6LOee0WRvGQWfprqWw/AYVMKIXG+gXz2Osfgl6R2bO/YDGnrAt+g8RMW5JLPTvMdtMEMR9Ry+YugzCt9SOOW+8NGKqSMTwRs6JgTjWYqUYZt/Ud1xeFRM4CeiiDiNIhpqoY3yZ+B6aMtE1FUi3XfUTZ3I2j2mO80LWygjhAATm3mNWLwjrnH4ZDEXkyICtZ63lbl/faqYa/xlNAXQ/UQCLEoGI+f8vs4+HnH80RW1NmLAYvLz5FVBuPYxB13On2Zi1NiNCLl0lCRwXSNJF3o80Oyy8FtAjNhjQxBHD0tWBP1L7kGZXoSZtOl+y/VFqBWmqwYSS0Suuz4a8R9OrIjoXjGK/Uf9YeHqotoPOMN8JsVEf6EoJ2hSn+TY7iVPj7CHjrp6oiJsx88Yiha+ih+ASxmpwBOgAtDdo06cIMVE/3tYBZNDc5HeaSNQnfO0pB+mflZ2FUAnHwBD+VS9iDjXb/BHe9g003W7QqHM0MTOH9yPSbkF2Uu3MxSZcOysaQIedu7F+c0+SX/8sPW2lKh897V4ZS8e0V0IJKkrhMXCEwtYsp3Mz74baOYfVAxOiDJq/AN0peEMdIbljVhW9+4CQ8l6C7KHXa5Dg9Bbd8KfQ+hj45hiduOI2cSuESi4CBQq3YLmCBas1VpoOtng2ML0qMisXUDE73d1uwH+PYsYVDmV9YsBx2HgZfZ9Tco64KO2dx0+GoU8KJ61zmuSz8CE3m95iU+MCLQ3EvRpSsxGWpp2QwykrCva+J0PXY4v/9P4eXXSgir2ZQsbCpwvfMdvkh2MhZsIZCSSWut9YfiW/VcTDBfOLkRxvJvgM4BJqDwvk+YaBJoJob7ywzwhHSHrQmJ89GOHxZ7hooxU9xkzuC1uKYJ0r2YL6hTH4Wdb7+vnvIckG+ck3RuUVLxCeuP+WyV1zunP2+cQij5nupdGC6T5LoTmbumY+AN1UUfw5QlaTuwCgD64PTQXrYXjG9u0zdiUQxx3xcIc3TLsdI/mObDhSJwphy9vm3x14JBJSr2XZdU6n3m4emh631DY+MAw7ubxHvWo6Kx4JA6Z/6ezV5A4OfFqcgo8JE9w5LbTxFvXnSCCRWgOF6PJulCzLKNnQ0peY4hz3RfVNBm/HVFbrUgKHU4/6Zp562h1o5qtIFXI3pj4V6nXFLf1x/PKbbNUglK37U9uyPAYTtnWu4eYBgnlqU6Nh+ilrg8mfyaVGZV+Cj0yd5szarGOwa8qjbU4l3tUjtZSyox0+nvx21kyk2nJJhWIUicB9iMJY/SQjHjDnP4KIfHoBEjaMyMwadcYeB0gIBQcAK2hePIoQEWw8tASyk3p9XtqmkHlPwX1hHU4pLgDzpz5esci+f5f0lzNuKfe0UoQAf0Bv02w8fR9UypqxesFkiCe4Pq05PzHjFVMzKaLcJ4Neij7sitVUUIYoZeaKDsk/2Fii/WDW0Xxo57njCCtND8sDM3PR7UXX0fcXpzb4AhshU9hvIMDbFXNdSjp5hrntO7K415+ZGEJgw/cF6EbdWfdtWA9AU1JdKSXc4adX7E4/5jnQZCQIEG2iswaJ1CB0HbPwqHLlZRnHk98fKcFr8Xf0Ppd0Dhdo4ng3X7S3VJjvSn3jp7Zcep6THMBGmtkFFKjHEAZNbn7FSLk2d5undDs9aeevU12gMBaXv8Ie4qJ/Kwtnf/96ipbKUgFIuQdoVl9LPxDiIj5HjEmtYvsT0vw3LPBpMyRiiYT8wAFLY/fYn5EN6nI6uQjYUBkpsPlxjjfWPNVX2m39UtdzZqPZaejrHmLA8Hu3hU29zOW04liBpidzQrtMtC56tNw9AIt2gFRiHOJAtyIDbamDblnfODYVVmMgeYA1R8v23EMJlWftbm/DfXjtBTpnrAhgV2RcarWfOLbB/5J/7CAUnTk8j+E74loO4CEk3Ig5SzVPvyVotB5WOv09o8nfNTv1XMmJ6Re9xqawpjc6UK6u7EyY1rb4xuWUTY3IBlYxzMP1QHu6H6K8/PDupv9eVK5ULKFdngcMdKxkmhlR2yTyZW/JH5gD701FHTLchNUvwOVxqUkkReaaMcNZtiU4nGfF6kb3u5Qu+iaISBeb9igx1ZGnLkI5VYy8fEyeETfVmJnkNi439pcKApx9SCBeRobHn9vnSDSCLv8AsMuRfseDXvgxWTh2eMsfmfPKUzgt9eDNpfLzUpS8a/6wkg/wpTvAZr2nkIUE2LWeCSH/K5ZbffJ7hoWXZlKTtYNM8Bj+jSnON2TkUPP6AnZ3lIraiS2pHuOKS6bBqi6BP6od8QC2DI30CyeZLLu9APX0dEnusixa+u804HsTquku5E9EMhJv25lcWhXSUbka59PR+bRQKSXklpJYs9CQ9VW42FRM3LOlprGF9Ux2GPTjSn7xiCPdJ1Nt5xnjmxMp3Ap5PLUKGC5xpwGLhxatwd8g68WwgMJyLwASzmFUfnQhpcbEyGp2wAA+9G6egyn5InK7TygiKTXI3j4ic2nW6XwOKjEeGTZajrdJBjQrIJvgFXdmprbuXtJNhoAY2/H/mbnrpi+aMO1L/1DiDzXUV9J5F3NkZTNRGEvDWhX2MRltLtg92fi6cWEGDRBl28Of6TgtGPLQk3nQyrr2pYoKWEwWdHuAilX+ATi24KxAfemZDHgOKF/vi5ybJAGzzRaz3aYd7r4tqPepb17f/ESfvd8AJ8V2abccKbhfp7sD052SR+aQRbeJaug6Z+87fUkwiAtmr6/p3RqdNJnV8L5Dilwcb1u66q0/l4WhStIhGXkqS7bXNcxjg6EJK30npojkC6ixVgcengP3XM3GIIZDU9TqH4WwI7aKwSfttp5VC6/HqoVIfOm4OC6sEh6kbanol5sbvNlwHtBHbElhim484qzYEBKGoBqNt+ff++m78Vo285KCEVQsqsSCGrW7C9axdaqEmOqametr7OWeWxISnoJvfxyYSeaQD6PhMh7NG8bKP4zSOhYDUC04krlBHVtT2bHwefraSlimSHLJj+HhY99UHNlY8wgO7cLwwC/oAjxS/mus6FrPNFbFwffZ+nyThK99mypap4BPObvKQYyBCf/QZfYiTf1+euZSOkLbKB/Enj4/hqZmbsFqeSfibO+Otw6twfbp+TksLCsijAedBQY1o/mnP1H9CBynz83YFQhamcnw11uOERYsGd9TyI0bF2DuVogBb8KtyEtS3IxXYVcobjDK+d/4CfPTo0deTb88WNEoRQOmygZyG5ou0TwiDewYi3BEKXZZVfNUPmIdpL/dpiYpgTjvAGWzPtycAYCXflDiDPXHler+nMe2A5VQeSfslQvR7/Sch2VvOSgZ/KP69pfH/YuLbqpyqzdk3k551M8ogXiigMAiMczN6GbtxVXTinLDSGN+iwFLw8gkD5Rs7UuoUJYYiQQENyLwcBJTIdfqZsTI4EcFTYyk+/0bAahOCK2lhI82C4A4OChOqvq/4W47L2DT39uwAbGVhBFFN+7O6sGiE/Jqd9c296DK3Ye6Y/jf+YH6ZeYr7/ru6Z9FpeI7R3/XHymddmkq14JN3CKFAhDZnPCSQZOwdcNBTyOm+P0RiHwEBLEhUFWT1gdejMnTf2dwW7ylcPpqNqjt0Sy/78hEDLq7OX5ni2pRaZteENukBRzkE/Kcbrzwkbe+66qSHwr3cXBMJgJEtBfpxWWqsQLY2thTbyWF+dapPn8rHok+Nrny74A3Eh0RT8UYz6aU7ci1kd1Od947jGgXfg8W8YWDUhIY1qOfbO8Xfu/Tc4KBD99es2+Xo7dEtGGyacubOt7FWIbjiIANpkQ4/30ym5hv6My5ipK4Abv/URxvX7J26jK7stL+baO5vUZ27wcdrHIye6w8YddL1EROXTinnknmepI96L1oUawqmYwRrv/LIKPS+8EkHRMmHDcvWSU3iRhRjOiouYFFAnwUFM8JJ+ur8YX00ypU2qP7rQURMiW41b8AMrM4cFw697XKfe5aDX8ZfIs3qRxMWd0+q2o5f8ycGpvPASH448sgFPsepfrWOYkRVf4CvbWMZLReRt+sa4q6cZML5VK/rBDI73QkiTBXCGTWM3D8kZul3LOc7JJkofjPyot+R/f5c+HC/9FqYp7Oy42WLHaAMsYOFEuAsT74T4NRfATcJu9z/v1hffk9GL/tl/HfHfBhYBWhIEowZu44b0yQIZ4IxQ6GMHpjY3+RjY8Rrrjwkxfhe0V1ZT8fhZLrmj2CaqmAPcAXDYB17CgY+ydQbnbYEV14AsCeopKNAVFK1OPDxZtWe/qEfgbeNoFiYlei2A2AGXo6X4vBEYPVojNAnRe+8pgclu1gr8zg4ObaOaZdkLaJu2da1W/mgqGtqqtVF2CytPbHEUK5OlDtPMa7HiCsENRhr8OlxxW5YYzNI5WwnkbX+tm0MkfvpfdqbJqrxvZvtlD/WSLhdLw77t5M+Cs5/Bp11ynmHiU5PwGWsGmAWSIlteqnyTDJXBtoF+y3Z8+mEM2MF0O4LNjhXKnuFUfE6OhnYrhy8D7fMIvpVxOXSypp0BkTi/AbgTigIh1vZcAvOsdQCOQXvaBVIXfjKLuRBS9ZjtBM1gbeK9O76z+M+t0dLXuj4U1NbDjwgXo26OqOJGzzdDBZ5RxJM30nwKeSSCi28A2Gx6/xgRl1fxzSiOlF9qtvSopMB+gS3VpzkpRFHZb+UHoJV2pRRFj6SUaHdHUt40avEzGRuJ/k3AZVsGMpoO0l5QnSFJo6TyB7/PH4vQN8zVm2lm/2GDwHoviASSO4I9cc8/SGjpblS6T5IPeX7P61qa2pMjizQCaQ/qFtZLoXl7u2IcdoHlCWsPPkStTgAVJja/VVRZWAwCte6We2mR/Wso0tug8iFqbJzjHUBolBtuQBOzoHOunr/sY5rV1lgnIU6pk6pYC3lRVN8iOC3Vu7F+XAEj8QiwBVcNpglSWkL6aZSO+5TPwMRCPTa/ltamziBl+f8peKPiTDCqhqTd5XWqCKp5yoxV6+osTG11VJOBeQViqOkFbnTqi0yfo2S6surzlz6fGH4naSRBJg3qEGui/v5iID/8tqppkh6obf2whPGa69JVAnxpCWT999hfKh8C3QpCP+vbJwq+leH7may84xisbxA6lgcX+3e40VaWk4pPwoBFZutVbHRtpO7whTkpGBnSw3GO5gmklLOJWwpa3W0DQp6DWKO3NjsxRBElyzVJVwxOpBS/FvammA//Zq13S91l3WflF/aIZzk/WoSqz7KWUlKKCXPserIWJnweNZmHGFqguguGHqitbROsM6G2heLbXnH1qXWU8HuG4A1xDBCIHvwgw7jjKLlFxpT10p5Pn/NsY91YnF1ni+RgqJcUr82F7OxLDNksNv3CyLXVen+7orMiyb3lWrMiP4sLOIcr3z8pnL11dzO/pVaK4asSRYU21tjAFR/AUmBpOdVM7DxszoXQ9xdj8H+svy/BQfsfy1T8B4jcOy9qqMLc3hH7xXQbr1qs09xlL4HgP28cKlpsmoDJgJsUMOpzSXoXj6BABpqS9BjBXA0vHsnuxkW9zSPemTCg7PhK3+ju2BT1Es0eKIPyLULZ9SLdSoA2to4n4J6qFdevGaXbCgAigMyTiQxIyxhAAAAAAABFWElGugAAAEV4aWYAAElJKgAIAAAABgASAQMAAQAAAAEAAAAaAQUAAQAAAFYAAAAbAQUAAQAAAF4AAAAoAQMAAQAAAAIAAAATAgMAAQAAAAEAAABphwQAAQAAAGYAAAAAAAAASAAAAAEAAABIAAAAAQAAAAYAAJAHAAQAAAAwMjEwAZEHAAQAAAABAgMAAKAHAAQAAAAwMTAwAaADAAEAAAD//wAAAqAEAAEAAADQAgAAA6AEAAEAAADZAAAAAAAAAA==)

Giả sử chúng tôi đã phát triển hệ thống đề xuất dựa trên người dùng và dựa trên mặt hàng, đồng thời chúng tôi muốn xây dựng một công cụ đề xuất kết hợp có trọng số. Chúng ta có thể kết hợp các phương pháp này bằng cách gán trọng số cho đề xuất đến từ mỗi hệ thống.

Trước tiên, bạn sẽ chạy riêng các hệ thống đề xuất dựa trên người dùng và dựa trên vật phẩm của mình để tạo các đề xuất cùng với điểm số tương ứng của chúng.

Ví dụ: giả sử chúng tôi đang cố gắng giới thiệu phim cho người dùng. Hệ thống dựa trên người dùng của bạn đề xuất “Phim A” với số điểm 4,5 và “Phim B” với số điểm 4,0, trong khi hệ thống dựa trên mục đề xuất “Phim A” với số điểm 3,5 và “Phim C” với số điểm của 4,7.

Để kết hợp những đề xuất này thành một danh sách đề xuất có trọng số duy nhất, bạn sẽ nhân điểm từ mỗi hệ thống với trọng số tương ứng rồi cộng chúng lại. Trọng số có thể được xác định dựa trên hiệu suất lịch sử của từng hệ thống, chẳng hạn như trọng lượng_user_based = 0,6 và trọng lượng_item_based = 0,4. Các trọng số này cho thấy rằng chúng tôi tin tưởng các đề xuất dựa trên người dùng hơn một chút so với các đề xuất dựa trên mặt hàng.

Bây giờ, hãy tính điểm cuối cùng cho các phim:

Đối với Phim A: Final_score = 0,6 x 4,5 (dựa trên người dùng) + 0,4 x 3,5 (dựa trên mặt hàng) = 4,1

Đối với Phim B: Final_score = 0,6 x 4,0 (dựa trên người dùng) + 0,4 x 0 (không được đề xuất dựa trên mục) = 2,4

Đối với Phim C: điểm_cuối cùng = 0,6 x 0 (không được đề xuất bởi người dùng) + 0,4 x 4,7 (dựa trên mục) = 1,88

Vì vậy, danh sách phim được đề xuất cuối cùng đang giảm dần thứ tự điểm sẽ là Phim A, Phim B và Phim C
"""

!pip install opendatasets

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy import stats
from ast import literal_eval

import opendatasets as od

od.download("https://www.kaggle.com/datasets/rounakbanik/the-movies-dataset?select=ratings.csv")

"""# User-based recommend system"""

df_rating = pd.read_csv('the-movies-dataset/ratings_small.csv')
movies = pd.read_csv('the-movies-dataset/movies_metadata.csv')

list = ['id','genres','title']
df_movies = movies[list]


# Danh sách các giá trị 'id' bạn muốn loại bỏ
values_to_drop = ['1997-08-20', '2012-09-29', '2014-01-01']

# Xóa các hàng có giá trị 'id' trong danh sách 'values_to_drop'
df_movies = df_movies[~df_movies['id'].isin(values_to_drop)]

agg_ratings = df.groupby('title').agg(mean_rating = ('rating', 'mean'),
                                                number_of_ratings = ('rating', 'count')).reset_index()

# Keep the movies with over 100 ratings
agg_ratings_GT100 = agg_ratings[agg_ratings['number_of_ratings']>100]

df_GT100 = pd.merge(df, agg_ratings_GT100[['title']], on='title', how='inner')

matrix = df_GT100.pivot_table(index='userId', columns='title', values='rating')


# Normalize user-item matrix
matrix_norm = matrix.subtract(matrix.mean(axis=1), axis = 'rows')

matrix_norm= matrix_norm.reset_index()
matrix_norm.userId = matrix_norm.userId - 1
matrix_norm= matrix_norm.set_index("userId")
user_similarity = matrix_norm.T.corr()

# Pick a user ID
picked_userid = 1

# Remove picked user ID from the candidate list
user_similarity.drop(index=picked_userid, inplace=True)

# Take a look at the data
user_similarity.head()


# Number of similar users
n = 10

# User similarity threashold
user_similarity_threshold = 0.3

# Get top n similar users
similar_users = user_similarity[user_similarity[picked_userid]>user_similarity_threshold][picked_userid].sort_values(ascending=False)[:n]
picked_userid_watched = matrix_norm[matrix_norm.index == picked_userid].dropna(axis=1, how='all')

# Print out top n similar users
print(f'The similar users for user {picked_userid} are', similar_users)

similar_user_movies = matrix_norm[matrix_norm.index.isin(similar_users.index)].dropna(axis=1, how='all')
similar_user_movies.drop(picked_userid_watched.columns,axis=1, inplace=True, errors='ignore')

# A dictionary to store item scores
item_score = {}

# Loop through items
for i in similar_user_movies.columns:
  # Get the ratings for movie i
  movie_rating = similar_user_movies[i]
  # Create a variable to store the score
  total = 0
  # Create a variable to store the number of scores
  count = 0
  # Loop through similar users
  for u in similar_users.index:
    # If the movie has rating
    if pd.isna(movie_rating[u]) == False:
      # Score is the sum of user similarity score multiply by the movie rating
      score = similar_users[u] * movie_rating[u]
      # Add the score to the total score for the movie so far
      total += score
      # Add 1 to the count
      count +=1
  # Get the average score for the item
  item_score[i] = total / count

# Convert dictionary to pandas dataframe
item_score = pd.DataFrame(item_score.items(), columns=['movie', 'movie_score_users'])

# Sort the movies by score
ranked_item_score = item_score.sort_values(by='movie_score', ascending=False)

# Select top m movies
m = 10
ranked_item_score.head(m)

ranked_item_score.head(len(df_movies)).reset_index()

ranked_item_score =  anked_item_score.head(len(df_movies))

"""# Iterm-based recommend system"""

df_rating = pd.read_csv('the-movies-dataset/ratings_small.csv')
movies = pd.read_csv('the-movies-dataset/movies_metadata.csv')

from ast import literal_eval
movies['genres'] = movies['genres'].fillna('[]').apply(literal_eval).apply(lambda x: [i['name'] for i in x] if isinstance(x, type([])) else [])

movies['movieId'] = range(1, len(movies) + 1)
list = ['title','genres']
df_movies = movies[list]
df_movies.insert(0, 'movieId', range(1, len(df_movies) + 1))

df = pd.merge(df_rating, df_movies, on='movieId')
agg_ratings = df.groupby('title').agg(mean_rating = ('rating','mean'), number_of_ratings = ('rating','count')).reset_index()
agg_ratings_new = agg_ratings[agg_ratings['number_of_ratings'] > 100]


df_GT100 = pd.merge(df, agg_ratings_new[['title']], on='title', how='inner')

matrix = df_GT100.pivot_table(index='title', columns='userId', values='rating')

matrix_norm = matrix.subtract(matrix.mean(axis = 1), axis = 0)

num_columns = len(matrix_norm.columns) - 1  # Lấy số lượng cột (trừ userId)
rename_dict = {i+1: i for i in range(1, num_columns + 1)}
print(rename_dict)
matrix_norm = matrix_norm.rename(columns=rename_dict)
matrix_norm.head()
item_similarity = matrix_norm.T.corr()

def item_based_rec(picked_userid=1, number_of_similar_items=5, number_of_recommendations =3):
  picked_userid_unwatched = pd.DataFrame(matrix_norm[picked_userid].isna()).reset_index()
  # Filltering unwatched of Users 2
  picked_userid_unwatched = picked_userid_unwatched[picked_userid_unwatched[picked_userid]==True]['title'].values.tolist()


  picked_userid_watched = pd.DataFrame(matrix_norm[picked_userid].dropna(axis=0, how='all')\
                              .sort_values(ascending=False))\
                              .reset_index()\
                              .rename(columns={picked_userid:'rating'})
  # data frame cho biết trọng số của picked_movie với toàn bộ movie còn lại
  rating_prediction ={}

  for picked_movie in picked_userid_unwatched:
    picked_movie_similarity_score = item_similarity[[picked_movie]].reset_index().rename(columns={picked_movie:'similarity_score'})

    # gộp 2 lại có 2 cột rating (tức x) và similarity (tức w)
    picked_userid_watched_similarity = pd.merge(left=picked_userid_watched,
                                                    right=picked_movie_similarity_score,
                                                    on='title',
                                                    how='inner')\
                                            .sort_values('similarity_score', ascending=False)[:5]

    # từ 2 cột x và w ở trên ta tính được average ( trọng số )
    predicted_rating = round(np.average(picked_userid_watched_similarity['rating'],
                                            weights=picked_userid_watched_similarity['similarity_score']), 6)
    rating_prediction[picked_movie] = predicted_rating
  import operator
  return sorted(rating_prediction.items(), key=operator.itemgetter(1), reverse=True)[:number_of_recommendations]
recommended_movie = item_based_rec(picked_userid=1, number_of_similar_items=10, number_of_recommendations = len(df_movies))

recommended_movie = pd.DataFrame(recommended_movie, columns = ['movie','movie_score_iterm'])
recommended_movie

df = pd.merge(item_score, recommended_movie, on='movie', how='inner')
df

"""tùy thuộc hệ số u và i  để đề xuất bộ phim theo ý muốn

u là hệ số đề xuất theo người dùng (user)

i là hệ số đề xuất theo vật phẩm (item)
"""

u = 0.6
i = 1 - u

df['final_score'] = df['movie_score']*u + df['movie_score_iterm']*i

df.sort_values(by='final_score', ascending = False)